#
# Module 'Commvault.VirtualServer'
#
# Generated by: Commvault
#
# Generated on: 5/22/2019
#

using module 'Commvault.TypeDefinitions'

Set-StrictMode -Version latest


function Get-CVVirtualMachine {
<#
.SYNOPSIS
    Method to retrieve the list of virtual machines in the CommCell.

.DESCRIPTION
    This method is implemented with Powershell paging support.
    Method to retrieve the list of virtual machines in the CommCell. 
    Output can be filtered by Protected/Unprotected status, active subclients of a client, and virtual machine Name.
    
.PARAMETER Name
    Filter output to virtual machine Name.

.PARAMETER ClientName
    Filter output by active subclients of ClientName.

.PARAMETER ClientId
    Filter output by active subclients of ClientId.

.PARAMETER ClientObject
    Filter output by active subclients of ClientObject.

.PARAMETER Id
    Specify Id representing virtual machine GUID.

.PARAMETER Protected
    Filter output by Protected virtual machines.

.PARAMETER UnProtected
    Filter output by UnProtected virtual machines.

.PARAMETER First
    Get list of virtual machines with paging support -First 20 (20 per page).

.PARAMETER Skip
    Get list of virtual machines with paging support -First 20 -Skip 5 (20 per page, skip first 5 pages).

.PARAMETER IncludeTotalCount
    Include total count of result record set.

.EXAMPLE
    Get-CVVirtualMachine

.EXAMPLE
    Get-CVVirtualMachine -Id 502df85e-7fe7-e1d6-8f0a-a9cdadd8c13e

.EXAMPLE
    Get-CVVirtualMachine -IncludeTotalCount -First 20 -Skip 5 (20 per page, skip first 5 pages)

.EXAMPLE
    Get-CVVirtualMachine -Protected

.EXAMPLE
    Get-CVVirtualMachine -UnProtected

.EXAMPLE
    Get-CVClient | Get-CVVirtualMachine -Protected

.EXAMPLE
    Get-CVVirtualMachine -Name autocs-winvm2

.EXAMPLE
    Get-CVVirtualMachine -ClientName Openstack-V2-client -Protected

.EXAMPLE
    Get-CVVirtualMachine -ClientName Openstack-V2-client -Name autocs-winvm2

.OUTPUTS
    Outputs [PSCustomObject] representing a virtual machine.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Get-CVVMlist')]
    [Alias('Perform-CVVMBrowse')]
    [CmdletBinding(DefaultParameterSetName = 'Default', SupportsPaging = $True)]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $False)]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $False, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $False, ParameterSetName = 'ByClientName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $False, ParameterSetName = 'ByClientId')]
        [ValidateNotNullorEmpty()]
        [Int32] $ClientId,

        [Parameter(Mandatory = $False, ParameterSetName = 'ByClientObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [switch] $Protected,
        [switch] $UnProtected
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            enum RunType {
                ById
                ByClient
                ByDefault
            }

            [RunType] $runType = 'ByDefault'

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $sessionObj = Get-CVSessionDetail 'InplaceRecover-VMDetails'
                $runType = 'ById'
            }
            elseif ($PSCmdlet.ParameterSetName -eq 'ByClientName' -or 
                    $PSCmdlet.ParameterSetName -eq 'ByClientId' -or 
                    $PSCmdlet.ParameterSetName -eq 'ByClientObject') {
                $sessionObj = Get-CVSessionDetail ($MyInvocation.MyCommand.Name + 'ByClient')
                $runType = 'ByClient'
            }
            else {
                $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            }

            $endpointSave = $sessionObj.requestProps.endpoint
            $protectedByActiveSubclientCount = 0
            $processCount = 0
            $totalCount = 0
            $pagingObj = @{ 'paging' = 0; 'pageSize' = $null; 'startPage' = $null; 'badParams' = $False }
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($runType -eq 'ById') {
                $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $Id)
                $pagingObj = ValidatePagingParameters $PSCmdlet.PagingParameters 1

                if (-not $pagingObj.badParams) {
                    $headerObj = Get-CVRESTHeader $sessionObj
                    $body     = ''
                    $payload = @{}
                    $payload.Add('headerObject', $headerObj)
                    $payload.Add('body', $body)
                    $validate = 'vmStatusInfoList'
        
                    $response = Submit-CVRESTRequest $payload $validate
    
                    if ($response.IsValid) {
                        foreach ($vmRecord in $response.Content.vmStatusInfoList) {
                            Write-Output $vmRecord
                            $processCount++
                        }
                    }
                }
            }
            else {
                if ($Protected) {
                    $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{status}', 1)
                }
                elseif ($UnProtected) {
                    $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{status}', 2)
                }
                else {
                    $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{status}', 0)
                }
    
                if ($runType -eq 'ByClient') {
                    if ($PSCmdlet.ParameterSetName -eq 'ByClientName') {
                        $clientObj = Get-CVClient -Name $ClientName
                        if ($null -ne $clientObj) {
                            $ClientObject = $clientObj
                        }
                        else {
                            Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                            return
                        }
                    }
                    elseif ($PSCmdlet.ParameterSetName -eq 'ByClientId') {
                        $clientObj = Get-CVClient -Id $ClientId
                        if ($null -ne $clientObj) {
                            $ClientObject = $clientObj
                        }
                        else {
                            Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having id [$ClientId]"
                            return
                        }
                    }

                    $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{id}', $ClientObject.clientId)
                    
                    if ($Protected) {
                        $activeSubclients = ($ClientObject | Get-CVSubclient)
                    }

                    $headerObj = Get-CVRESTHeader $sessionObj
                    $body     = ''
                    $payload = @{}
                    $payload.Add('headerObject', $headerObj)
                    $payload.Add('body', $body)
                    $validate = 'vmStatusInfoList'
        
                    $response = Submit-CVRESTRequest $payload $validate
    
                    if ($response.IsValid) {
                        $totalCount = $response.Content.vmStatusInfoList.Length
                        $pagingObj = ValidatePagingParameters $PSCmdlet.PagingParameters $totalCount
                        if ($pagingObj.paging) {
                            if ($pagingObj.startPage -eq 0) { $index = 0 }
                            else { $index = ($pagingObj.startPage * $pagingObj.pageSize) }
                            $pageItemCount = 0
                            for (; $index -lt $response.Content.vmStatusInfoList.Length; $index++) {
                                if (-not [String]::IsNullOrEmpty($Name)) {
                                    if ($vmRecord.name -ne $Name) {
                                        continue
                                    }
                                }
                                if ($Protected -and ($response.Content.vmStatusInfoList[$index].vmStatus -eq 1)) {
                                    foreach ($subclient in $activeSubclients) {
                                        if ($subclient.subclientId -eq $response.Content.vmStatusInfoList[$index].subclientId) {
                                            Write-Output $response.Content.vmStatusInfoList[$index]
                                            $protectedByActiveSubclientCount++
                                            $processCount++
                                            $pageItemCount++
                                            break
                                        }
                                    }
                                }
                                else {
                                    Write-Output $response.Content.vmStatusInfoList[$index]
                                    $processCount++
                                    $pageItemCount++
                                }
                                if ($index -eq $response.Content.vmStatusInfoList.Length - 1) {
                                    break
                                }
                                elseif ($pageItemCount -eq $pagingObj.pageSize) {
                                    $pageItemCount = 0
                                    Read-Host '[Enter] for next page'
                                }
                            }
                        }
                        elseif (-not $pagingObj.badParams) {
                            foreach ($vmRecord in $response.Content.vmStatusInfoList) {
                                if (-not [String]::IsNullOrEmpty($Name)) {
                                    if ($vmRecord.name -ne $Name) {
                                        continue
                                    }
                                }
                                if ($Protected -and ($vmRecord.vmStatus -eq 1)) {
                                    foreach ($subclient in $activeSubclients) {
                                        if ($subclient.subclientId -eq $vmRecord.subclientId) {
                                            Write-Output $vmRecord
                                            $protectedByActiveSubclientCount++
                                            $processCount++
                                            break
                                        }
                                    }
                                }
                                else {
                                    Write-Output $vmRecord
                                    $processCount++
                                }
                            }
                        }
                    }

                    if ($PSCmdlet.ParameterSetName -eq 'ByClientObject') {
                        if ($processCount -eq 0) {
                            if ($Protected) {
                                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no protected virtual machines found for client [$($ClientObject.clientName)]"      
                            }
                            else {
                                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no virtual machines found for client [$($ClientObject.clientName)]"      
                            }
                        }
                        else {
                            $processCount = 0
                        }
                    }
                }
                else { # ByDefault
                    # query with startPage=0, pageSize=0 to get totalRecords
                    $pagingInfo = '0,0'
                    $headerObj = Get-CVRESTHeader $sessionObj $pagingInfo
                    $body = ''
                    $payload = @{}
                    $payload.Add('headerObject', $headerObj)
                    $payload.Add('body', $body)
                    $validate = 'vmStatusInfoList'
                    $totalCount = (Submit-CVRESTRequest $payload $validate).Content.totalRecords
                    if ([String]::IsNullOrEmpty($Name)) { # vm name filter overrides paging functionality
                        $pagingObj = ValidatePagingParameters $PSCmdlet.PagingParameters $totalCount
                    }

                    if (-not $pagingObj.badParams) {
                        do {
                            $pagingInfo = '{startPage},{pageSize}'
                            
                            if ($pagingObj.paging) {
                                $pagingInfo = $pagingInfo -creplace ('{startPage}', $pagingObj.startPage)
                                $pagingInfo = $pagingInfo -creplace ('{pageSize}', $pagingObj.pageSize)
                            }
                            else { # TR - 190508-795
                                $pagingInfo = $pagingInfo -creplace ('{startPage}', 0)
                                $pagingInfo = $pagingInfo -creplace ('{pageSize}', $totalCount)
                            }
                            
                            $pagingObj.startPage++

                            $headerObj = Get-CVRESTHeader $sessionObj $pagingInfo
                            $payload.Clear()
                            $payload.Add('headerObject', $headerObj)
                            $payload.Add('body', $body)
                
                            $response = Submit-CVRESTRequest $payload $validate
            
                            if ($response.IsValid) {
                                foreach ($vmRecord in $response.Content.vmStatusInfoList) {
                                    if (-not [String]::IsNullOrEmpty($Name)) {
                                        if ($vmRecord.name -ne $Name) {
                                            continue
                                        }
                                    }
                                    Write-Output $vmRecord
                                    $processCount++
                                }
                
                                if ($pagingObj.paging) {
                                    if (($pagingObj.startPage * $pagingObj.pageSize) -ge $totalCount) {
                                        $pagingObj.paging = 0
                                    }
                                    else {
                                        Read-Host '[Enter] for next page'
                                    }
                                }
                            }
                            else {
                                $pagingObj.paging = 0
                            }
                        } until (-not $pagingObj.paging)
                    }
                }
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"

        try {
            if ($PSCmdlet.PagingParameters.IncludeTotalCount) {
                [double] $accuracy = 1.0
                if ($runType -eq 'ById') { $PSCmdlet.PagingParameters.NewTotalCount(1, $accuracy) }
                else { $PSCmdlet.PagingParameters.NewTotalCount($totalCount, $accuracy) }
            }
    
            if ($Protected -and $runType -eq 'ByClient') {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): protected virtual machines with active subclients [$protectedByActiveSubclientCount]"
            }
            elseif ($PSCmdlet.ParameterSetName -ne 'ByClientObject' -and $processCount -eq 0 -and -not $pagingObj.badParams) {
                if (-not [String]::IsNullOrEmpty($Name)) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having name [$Name]"
                }
                elseif ($Protected) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no protected virtual machines found"
                }
                elseif ($UnProtected) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no unprotected virtual machines found"
                }
                else {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no virtual machines found"
                }
            }
        }
        catch {
            throw $_
        }
    }
}


function Get-CVVirtualMachineBackupTime {
<#
.SYNOPSIS
    Method to retrieve the last backup details of virtual machines in the CommCell.

.DESCRIPTION
    Method to retrieve the last backup details of virtual machines in the CommCell.
    
.PARAMETER Name
    Filter output to virtual machine Name.

.PARAMETER ClientName
    Filter output by active subclients of ClientName.

.PARAMETER ClientObject
    Filter output by active subclients of ClientObject.

.EXAMPLE
    Get-CVVirtualMachineBackupTime

.EXAMPLE
    Get-CVVirtualMachineBackupTime -ClientName Openstack-V2-client

.EXAMPLE
    Get-CVVirtualMachineBackupTime -ClientName Openstack-V2-client -Name autocs-winvm2

.EXAMPLE
    Get-CVClient | Get-CVVirtualMachineBackupTime

.OUTPUTS
    Outputs [PSCustomObject] representing virtual machine last backup details.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Get-CVLastBackup')]
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $False)]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $False, ParameterSetName = 'ByClient')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $False, ParameterSetName = 'ByClient', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            if ($null -ne $ClientObject -and -not [String]::IsNullOrEmpty($Name)) {
                $vmRecords = Get-CVVirtualMachine -Name $Name -ClientObject $ClientObject -Protected
            }
            elseif ($null -ne $ClientObject) {
                $vmRecords = Get-CVVirtualMachine -ClientObject $ClientObject -Protected
            }
            elseif (-not [String]::IsNullOrEmpty($Name) -and -not [String]::IsNullOrEmpty($ClientName)) {
                $vmRecords = Get-CVVirtualMachine -Name $Name -ClientName $ClientName -Protected
            }
            elseif (-not [String]::IsNullOrEmpty($Name)) {
                $vmRecords = Get-CVVirtualMachine -Name $Name -Protected
            }
            elseif (-not [String]::IsNullOrEmpty($ClientName)) {
                $vmRecords = Get-CVVirtualMachine -ClientName $ClientName -Protected
            }
            else {
                $vmRecords = Get-CVVirtualMachine -Protected
            }

            if ($null -ne $vmRecords) {
                foreach ($record in $vmRecords) {
                    $lastbackupTime = $record |`
                    Select-Object  @{Name='LastBackupTime';Expression={[timezone]::CurrentTimeZone.ToLocalTime(([datetime]'1/1/1970').AddSeconds($_.bkpEndTime))}}|`
                    Select-Object -ExpandProperty LastBackupTime
                    [PSCustomObject] $custom = New-Object PSObject
                    $custom | Add-Member -NotePropertyName 'Host' -NotePropertyValue $record.vmHost
                    $custom | Add-Member -NotePropertyName 'Agent' -NotePropertyValue $record.vmAgent
                    $custom | Add-Member -NotePropertyName 'Subclient' -NotePropertyValue $record.subclientName
                    $custom | Add-Member -NotePropertyName 'Name' -NotePropertyValue $record.name
                    $custom | Add-Member -NotePropertyName 'JobId' -NotePropertyValue $record.vmBackupJob
                    $custom | Add-Member -NotePropertyName 'BackupTime' -NotePropertyValue $lastbackupTime
                    
                    Write-Output $custom
                }
            }
            else {
                if (-not [String]::IsNullOrEmpty($Name)) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): last backup time not found having the virtual machine [$Name]"
                }
                elseif (-not [String]::IsNullOrEmpty($ClientName)) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): last backup time(s) not found having client [$ClientName]"
                }
                else {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no protected virtual machine records found"
                }
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}


function Backup-CVVirtualMachine {
<#
.SYNOPSIS
    Method to initiate backup of specified virtual machine.

.DESCRIPTION
    Method to initiate backup of specified virtual machine.
    
.PARAMETER Name
    Virtual machine Name.

.PARAMETER Id
    Virtual machine Id: this is the virtual machine GUID.

.PARAMETER ClientName
    Virtual machine associated ClientName.

.PARAMETER ClientObject
    Virtual machine associated client specified by piped ClientObject.

.PARAMETER SubclientName
    Virtual machine associated SubclientName. Subclient specification with this parameter will override the default behavior.

.PARAMETER BackupLevel
    Specify BackupLevel: Full, Incremental (default), Synthfull.

.PARAMETER Protected
    Use this switch to filter legacy, unprotected virtual machines when specifed by Name.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Backup-CVVirtualMachine

.EXAMPLE
    Backup-CVVirtualMachine -ClientName Openstack-V2-client -Name autocs-winvm2

.EXAMPLE
    Backup-CVVirtualMachine -ClientName Openstack-V2-client -Name autocs-winvm2 -BackupLevel Full

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Backup-CVVM')]
    [CmdletBinding(DefaultParameterSetName = 'ByName', SupportsShouldProcess = $True, ConfirmImpact = 'Low')]
    [OutputType([PSCustomObject])]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $SubclientName,

        [Alias('JobType')]
        [Parameter(Mandatory = $False)]
        [CVVSABackupType] $BackupType = 'Incremental',

        [Switch] $Protected,
        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $vmObj = (Get-CVVirtualMachine -Id $Id)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having id [$Id]"
                    return
                }
            }
            else {
                $subclientObj = $null

                if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                    $clientObj = Get-CVClient -Name $ClientName
                    if ($null -ne $clientObj) {
                        $ClientObject = $clientObj
                    }
                    else {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                        return
                    }
                }

                if ($Protected) {
                    $vmObj = ($ClientObject | Get-CVVirtualMachine -Name $Name -Protected)
                }
                else {
                    $vmObj = ($ClientObject | Get-CVVirtualMachine -Name $Name)
                }
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having name [$Name]"
                    return
                }
                elseif (HasProperty $vmObj 'Length') {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): multiple virtual machine objects returned for client [$($ClientObject.clientName)] having name [$Name]"
                    return
                }
            }

            $jobObj = GetVirtualMachineJobObject

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $jobObj['clientId'] = $vmObj.pseudoClient.clientId
            }
            else {
                $jobObj['clientId'] = $ClientObject.clientId
            }

            $jobObj['vmName'] = $vmObj.name
            $jobObj['backupLevel'] = $BackupType.value__

            if ($vmObj.vmStatus -eq 1) {
                $jobObj['subclientId']  = $vmObj.subclientId
            }
            else { #This condition will be executed when provided VM has never been backed-up
                if (-not [String]::IsNullOrEmpty($SubclientName)) {
                    $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                    if ($null -eq $subclientObj) { 
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName] for client [$ClientName]"      
                        return
                    }
                }
                else {
                    $globalsObj = Get-CVCommCellGlobals 
                    $SubclientName = $globalsObj.defaultSubclient 
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient name not provided...retrieving default subclient"
                    $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                    if ($null -eq $subclientObj) {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName]"
                        return
                    }
                }
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine has never been backed-up...adding to subclient [$($subclientObj.subclientName)]"
                $jobObj['subclientId'] = $subclientObj.subclientId
            }

            $headerObj = Get-CVRESTHeader $sessionObj
            $body = (PrepareBackupTaskBodyJson $jobObj $vmObj.strGUID).body
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'taskId'
            
            if ($Force -or $PSCmdlet.ShouldProcess($vmObj.name)) {
                $response = Submit-CVRESTRequest $payload $validate
            }
            else {
                $response = Submit-CVRESTRequest $payload $validate -DryRun
            }

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): backup request declined for virtual machine [$($vmObj.name)]"
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}


function Get-CVVirtualMachineActiveMounts {
<#
.SYNOPSIS
    Method to retrieve list of active mounts for specified source virtual machine.

.DESCRIPTION
    Method to retrieve list of active mounts for specified source virtual machine.
    
.PARAMETER Name
    Source virtual machine Name.

.PARAMETER ClientName
    Source virtual machine associated ClientName.

.PARAMETER SubclientName
    Specify SubclientName to override the default behavior.

.PARAMETER Id
    Specify Id representing source virtual machine GUID.

.EXAMPLE
    Get-CVVirtualMachineActiveMounts | Select-Object -ExpandProperty virtualMachines

.EXAMPLE
    Get-CVVirtualMachineActiveMounts -Id 502d15b2-9f17-1df9-5231-20b22d73b952 | Select-Object -ExpandProperty virtualMachines

.EXAMPLE
    Get-CVVirtualMachineActiveMounts -Name LSRegVm1 -ClientName vsa-vc65.testlab.commvault.com -SubclientName LSRegVMG1 | Select-Object -ExpandProperty virtualMachines

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [CmdletBinding(DefaultParameterSetName = 'ByName')]
    [OutputType([PSCustomObject])]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $SubclientName
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $Id)
            }
            else {
                $subclientObj = $null

                if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                    $clientObj = Get-CVClient -Name $ClientName
                    if ($null -ne $clientObj) {
                        $ClientObject = $clientObj
                    }
                    else {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                        return
                    }
                }
    
                if (-not [String]::IsNullOrEmpty($SubclientName)) {
                    $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                    if ($null -eq $subclientObj) { 
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName] for client [$ClientName]"      
                        return
                    }
                }
                else { # use default subclient
                    $globalsObj = Get-CVCommCellGlobals 
                    $SubclientName = $globalsObj.defaultSubclient 
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient name not provided...retrieving default subclient"
                    $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                    if ($null -eq $subclientObj) {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName]"
                        return
                    }
                }
        
                $vmObj = ($ClientObject | Get-CVVirtualMachine -Name $Name)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having name [$Name]"
                    return
                }

                $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $vmObj.strGUID)
            }

            $headerObj = Get-CVRESTHeader $sessionObj
            $body = ''
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'virtualMachines'
            
            $response = Submit-CVRESTRequest $payload $validate

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                if ($PSCmdlet.ParameterSetName -eq 'ById') {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no active live mounts found for virtual machine [$Id]"      
                }
                else {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): no active live mounts found for virtual machine [$Name]"      
                }
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}
    

function Mount-CVVirtualMachine {
<#
.SYNOPSIS
    Method to initiate live mount of specified virtual machine.

.DESCRIPTION
    Method to initiate live mount of specified virtual machine from specified media.
    
.PARAMETER Name
    Source virtual machine Name.

.PARAMETER ClientName
    Source virtual machine associated ClientName.

.PARAMETER SubclientName
    Specify SubclientName to override the default behaviour.

.PARAMETER Id
    Specify Id representing source virtual machine GUID.

.PARAMETER NetworkName
    Specify NetworkName for live mount operation.

.PARAMETER PolicyName
    Specify PolicyName for live mount operation.

.PARAMETER JobId
    Specify JobId to live mount from particular backup job.

.PARAMETER LiveMountVMName
    Specify LiveMountVMName to override default naming behavior.

.PARAMETER ExpirationInHours
    Specify ExpirationInHours for in-place live mount.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Mount-CVVirtualMachine -Id 502df85e-7fe7-e1d6-8f0a-a9cdadd8c13e

.EXAMPLE
    Mount-CVVirtualMachine -ClientName VSAAZURE -Name AzureProxyV2CS

.EXAMPLE
    Mount-CVVirtualMachine -ClientName VSAAZURE -Name AzureProxyV2CS -SubclientName test-2567

.EXAMPLE
    Mount-CVVirtualMachine -ClientName VSAAZURE -Name AzureProxyV2CS -SubclientName test-2567 -PolicyName policy1 -JobId 12345 -LiveMountVMName AzureProxyV2CS_m1 -ExpirationInHours 3

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Mount-CVVM')]
    [CmdletBinding(DefaultParameterSetName = 'ByName', SupportsShouldProcess = $True, ConfirmImpact = 'Medium')]
    [OutputType([PSCustomObject])]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $SubclientName,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $NetworkName,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $PolicyName,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $JobId,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $LiveMountVMName,

        [Parameter(Mandatory = $False )]
        [ValidateNotNullorEmpty()]
        [String] $ExpirationInHours,

        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $vmObj = (Get-CVVirtualMachine -Id $Id)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having id [$Id]"
                    return
                }
            }
            else {
                $subclientObj = $null

                if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                    $clientObj = Get-CVClient -Name $ClientName
                    if ($null -ne $clientObj) {
                        $ClientObject = $clientObj
                    }
                    else {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                        return
                    }
                }
    
                if (-not [String]::IsNullOrEmpty($SubclientName)) {
                    $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                    if ($null -eq $subclientObj) { 
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName] for client [$ClientName]"      
                        return
                    }
                }
                else { # use default subclient
                    $globalsObj = Get-CVCommCellGlobals 
                    $SubclientName = $globalsObj.defaultSubclient 
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient name not provided...retrieving default subclient"
                    $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                    if ($null -eq $subclientObj) {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName]"
                        return
                    }
                }
        
                $vmObj = ($ClientObject | Get-CVVirtualMachine -Name $Name)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having name [$Name]"
                    return
                }
            }
                
            $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $vmObj.strGUID)

            $jobObj = @{}
            $jobObj.Add('networkName', $NetworkName)
            $jobObj.Add('policyName', $PolicyName)
            $jobObj.Add('jobId', $JobId)
            $jobObj.Add('liveMountVMName', $LiveMountVMName)
            $jobObj.Add('expirationInHours', $ExpirationInHours)
    
            $headerObj = Get-CVRESTHeader $sessionObj
            $body = (PrepareMountTaskBodyJson $jobObj).body
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'taskId'
            
            if ($Force -or $PSCmdlet.ShouldProcess($vmObj.name)) {
                $response = Submit-CVRESTRequest $payload $validate
            }
            else {
                $response = Submit-CVRESTRequest $payload $validate -DryRun
            }

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): mount request declined for virtual machine [$($vmObj.name)]"      
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}

    
function Dismount-CVVirtualMachine {
<#
.SYNOPSIS
    Method to initiate dismount of live mounted virtual machine.

.DESCRIPTION
    Method to initiate dismount of live mounted virtual machine.
    
.PARAMETER Id
    Specify Id representing live mounted virtual machine GUID.

.PARAMETER ActiveMountObject
    Specify ActiveMountObject containing live mounted virtual machine GUID.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Dismount-CVVirtualMachine -Id f7db5498-2bb5-4152-9064-dd50df07eff5

.EXAMPLE
    Get-CVVirtualMachineActiveMounts -ClientName VSAAZURE -Name AzureProxyV2CS -SubclientName test-2567 | Dismount-CVVirtualMachine

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [CmdletBinding(DefaultParameterSetName = 'ById', SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    [OutputType([PSCustomObject])]
    param(
        [Parameter(Mandatory = $True, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ActiveMountObject,

        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $vmObj = (Get-CVVirtualMachine -Id $Id)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having id [$Id]"
                    return
                }
            }
            elseif ((HasProperty $ActiveMountObject 'vm') -and (HasProperty $ActiveMountObject.vm 'vmGUID')) {
                $vmObj = (Get-CVVirtualMachine -Id $ActiveMountObject.vm.vmGUID)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having id [$($ActiveMountObject.vm.vmGUID)]"
                    return
                }
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): live mount virtual machine GUID property not found on [$ActiveMountObject]"
                return
            }

            $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $vmObj.strGUID)

            $headerObj = Get-CVRESTHeader $sessionObj
            $body = ''
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            #GRSTODO: what is valid response id?
            $validate = 'taskId'
            
            if ($Force -or $PSCmdlet.ShouldProcess($vmObj.name)) {
                $response = Submit-CVRESTRequest $payload $validate
            }
            else {
                $response = Submit-CVRESTRequest $payload $validate -DryRun
            }

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): dismount request declined for virtual machine [$($vmObj.name)]"      
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}

                
function Restore-CVVirtualMachine {
<#
.SYNOPSIS
    Method to initiate in-place restore/recovery of specified virtual machine.

.DESCRIPTION
    Method to initiate in-place restore/recovery of specified virtual machine.
    
.PARAMETER Name
    Virtual machine Name.

.PARAMETER ClientName
    Virtual machine associated ClientName.

.PARAMETER ClientObject
    Virtual machine associated piped ClientObject.

.PARAMETER Id
    Specify Id representing virtual machine GUID.

.PARAMETER Overwrite
    Switch to Overwrite specified virtual machine.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Restore-CVVirtualMachine

.EXAMPLE
    Restore-CVVirtualMachine -Id 502df85e-7fe7-e1d6-8f0a-a9cdadd8c13e

.EXAMPLE
    Restore-CVVirtualMachine -ClientName Openstack-V2-client -Name autocs-winvm2

.EXAMPLE
    Restore-CVVirtualMachine -ClientName Openstack-V2-client -Name autocs-winvm2 -Overwrite

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Restore-CVVM')]
    [CmdletBinding(DefaultParameterSetName = 'ByName', SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    [OutputType([PSCustomObject])]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Switch] $Overwrite,
        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $vmObj = (Get-CVVirtualMachine -Id $Id)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having id [$Id]"
                    return
                }
            }
            else {
                if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                    $clientObj = Get-CVClient -Name $ClientName
                    if ($null -ne $clientObj) {
                        $ClientObject = $clientObj
                    }
                    else {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                        return
                    }
                }
    
                $vmObj = ($ClientObject | Get-CVVirtualMachine -Name $Name)
                if ($null -ne $vmObj) {
                    if (-not $vmObj.vmStatus -eq 1) { 
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): protected status not found for virtual machine having name [$($vmObj.name)]"
                        return 
                    }
                }
                else {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having name [$Name]"
                    return
                }
            }

            $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $vmObj.strGUID)

            $restoreObj = @{}
            $restoreObj.Add('inPlaceRestore', $True)
            $restoreObj.Add('overwrite', $Overwrite.IsPresent)
            $restoreObj.Add('vmProps', $vmObj)

            $headerObj = Get-CVRESTHeader $sessionObj
            $body = (PrepareInPlaceTaskBodyJson $restoreObj).body
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'taskId'

            if ($Force -or $PSCmdlet.ShouldProcess($vmObj.name)) {
                $response = Submit-CVRESTRequest $payload $validate
            }
            else {
                $response = Submit-CVRESTRequest $payload $validate -DryRun
            }

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): in-place restore request declined for virtual machine [$($vmObj.name)]"
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}


function Restore-CVVirtualMachineOutofPlace {
<#
.SYNOPSIS
    Method to initiate out-of-place restore/recovery of specified virtual machine.

.DESCRIPTION
    Method to initiate out-of-place restore/recovery of specified virtual machine.
    
.PARAMETER Name
    Virtual machine Name.

.PARAMETER ClientName
    Virtual machine associated ClientName.

.PARAMETER ClientObject
    Virtual machine associated piped ClientObject.

.PARAMETER Id
    Specify Id representing virtual machine GUID.

.PARAMETER JobId
    Specify JobId from which to restore/recover.

.PARAMETER CopyPrecedence
    Specify CopyPrecedence from which the restore/recovery should occur. Primary, secondary or cloud.

.PARAMETER PowerON
    Switch to PowerOn restored/recovered virtual machine.

.PARAMETER DestHypervisorType
    Specify DestHypervisorType: VMware, HyperV, AWS, Azure, OpenStack

.PARAMETER Overwrite
    Switch to Overwrite specified virtual machine.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Restore-CVVirtualMachineOutofPlace

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Restore-CVVMOut')]
    [CmdletBinding(DefaultParameterSetName = 'ByName', SupportsShouldProcess = $True, ConfirmImpact = 'Medium')]
    [OutputType([PSCustomObject])]
    param(
        [Alias('VMName')]
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $Name,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ById')]
        [ValidateNotNullorEmpty()]
        [String] $Id,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Parameter(Mandatory = $False)]   
        [ValidateNotNullorEmpty()]
        [Int32] $JobId,

        [Parameter(Mandatory = $False)]   
        [CVCopyPrecedence] $CopyPrecedence = 'Primary',

        [Parameter(Mandatory = $False)]   
        [CVVSAHyperVisorType] $DestHypervisorType = 'vmware',

        [Parameter(Mandatory = $False)]   
        [Hashtable] $OutofPlaceRecoveryProps,

        [Switch] $PowerOn,
        [Switch] $Overwrite,
        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            if ($PSCmdlet.ParameterSetName -eq 'ById') {
                $vmObj = (Get-CVVirtualMachine -Id $Id)
                if ($null -eq $vmObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having id [$Id]"
                    return
                }
            }
            else {
                if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                    $clientObj = Get-CVClient -Name $ClientName
                    if ($null -ne $clientObj) {
                        $ClientObject = $clientObj
                    }
                    else {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                        return
                    }
                }
    
                $vmObj = ($ClientObject | Get-CVVirtualMachine -Name $Name)
                if ($null -ne $vmObj) {
                    if (-not $vmObj.vmStatus -eq 1) { 
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): protected status not found for virtual machine having name [$($vmObj.name)]"
                        return 
                    }
                }
                else {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine not found having name [$Name]"
                    return
                }
    
            }

            $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $vmObj.strGUID)

            $restoreObj = @{}
            $restoreObj.Add('inPlaceRestore', $False)
            $restoreObj.Add('overwrite', $Overwrite.IsPresent)
            $restoreObj.Add('powerOn', $PowerOn.IsPresent)
            $restoreObj.Add('hypervisorType', $DestHypervisorType.value__)
            $restoreObj.Add('vmProps', $vmObj)
            $restoreObj.Add('clientName', $ClientObj.clientName)
            if ($JobId -gt 0) { $restoreObj.Add('jobId', $JobId) }
            $restoreObj.Add('copyPrecedence', $CopyPrecedence.value__)
            
            if ($null -ne $OutofPlaceRecoveryProps) {
                $recoveryProps = ParseOutOfPlaceRestoreOptions -Options $OutofplaceRecoveryProps -HvType $DestHypervisorType 
                if ($null -ne $recoveryProps) {
                    $recoveryProps.Add('destinationInfo', $True)
                    $restoreObj.Add('outofPlaceProps', $recoveryProps)
                }
            }

            $headerObj = Get-CVRESTHeader $sessionObj
            $body = (PrepareOutofPlaceTaskBodyJson $restoreObj).body
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'taskId'
            
            if ($Force -or $PSCmdlet.ShouldProcess($vmObj.name)) {
                $response = Submit-CVRESTRequest $payload $validate
            }
            else {
                $response = Submit-CVRESTRequest $payload $validate -DryRun
            }

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): out-of-place restore request declined for virtual machine [$($vmObj.name)]"
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}

        
function Add-CVVirtualMachine {
<#
.SYNOPSIS
    Method to add virtual server subclient content.

.DESCRIPTION
    Method to add virtual server subclient content.
    
.PARAMETER ClientName
    ClientName of the client in which subclient resides.

.PARAMETER ClientObject
    Piped ClientObject of the client in which subclient resides.

.PARAMETER SubclientName
    SubclientName to which content should be added. If this parameter not passed, assumes default subclient.

.PARAMETER Entity
    Name of the Entity to be added. Multiple entities can be added using a comma separated list. Virtual machine Name, datastore name etc.

.PARAMETER EntityType
    EntityType can be VMName (default), Host or Cluster etc.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Add-CVVirtualMachine -Entity LSRegVm1 -ClientName vsa-vc65.testlab.commvault.com

.EXAMPLE
    Add-CVVirtualMachine -Entity LSRegVm1 -ClientName vsa-vc65.testlab.commvault.com -SubclientName LSRegVMG1    

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.
    If successful, specified content is added to the subclient.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Add-CVVM')]
    [CmdletBinding(DefaultParameterSetName = 'ByName', SupportsShouldProcess = $True, ConfirmImpact = 'Medium')]
    [OutputType([PSCustomObject])]
    param(
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Parameter(Mandatory = $False)]
        [ValidateNotNullorEmpty()]
        [String] $SubclientName,

        [Parameter(Mandatory = $True)]
        [ValidateNotNullorEmpty()]
        [String] $Entity,

        [Parameter(Mandatory = $False)]
        [CVVSAContentEntityType] $EntityType = 'VMName',

        [Parameter(DontShow)]
        [CVVSAContentOperationType] $OperationType = 'ADD',

        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"

        try {
            $sessionObj = Get-CVSessionDetail $MyInvocation.MyCommand.Name
            $endpointSave = $sessionObj.requestProps.endpoint
        }
        catch {
            throw $_
        }
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            $sessionObj.requestProps.endpoint = $endpointSave

            $subclientObj = $null

            if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                $clientObj = Get-CVClient -Name $ClientName
                if ($null -ne $clientObj) {
                    $ClientObject = $clientObj
                }
                else {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): client not found having name [$ClientName]"
                    return
                }
            }

            if (-not [String]::IsNullOrEmpty($SubclientName)) {
                $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                if ($null -eq $subclientObj) { 
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName] for client [$ClientName]"      
                    return
                }
            }
            else { # use default subclient
                $globalsObj = Get-CVCommCellGlobals 
                $SubclientName = $globalsObj.defaultSubclient 
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient name not provided...retrieving default subclient"
                $subclientObj = $ClientObject | Get-CVSubclient -Name $SubclientName
                if ($null -eq $subclientObj) {
                    Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient not found having name [$SubclientName]"
                    return
                }
            }

            $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{subclientId}', $subclientObj.subclientId) 

            $entityObj = GetVirtualMachineEntityObject
            $entityObj['entity']        = $Entity                # Entity Name can be: VM name in format like VM1, VM2, VM3 
            $entityObj['entityType']    = $EntityType            # Virtualization entity type. ESX Host, Datastore, VM, Cluster...etc 
            $entityObj['operationType'] = $OperationType         # DELETE or ADD or OVERWRITE
            $entityObj['clientId']      = $ClientObject.clientId # Virtualization clientId

            $bodyJson = PrepareContentBodyJson -EntityObj $entityObj
            if ($null -eq $bodyJson) {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): entity not found for add/remove virtual machine request"
                return
            }
            else {
                $body = $bodyJson.body
            }
            
            $headerObj = Get-CVRESTHeader $sessionObj
            $payload = @{}
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'response'

            if ($Force -or $PSCmdlet.ShouldProcess($Entity)) {
                $response = Submit-CVRESTRequest $payload $validate
            }
            else {
                $response = Submit-CVRESTRequest $payload $validate -DryRun
            }

            if ($response.IsValid) {
                Write-Output $response.Content
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): subclient content modification request declined for entity [$Entity]"      
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}
    
    
function Remove-CVVirtualMachine {
<#
.SYNOPSIS
    Method to remove virtual server subclient content.

.DESCRIPTION
    Method to remove virtual server subclient content.
    
.PARAMETER ClientName
    ClientName of the client in which subclient resides.

.PARAMETER ClientObject
    Piped ClientObject of the client in which subclient resides.

.PARAMETER SubclientName
    SubclientName from which content should be removed. If this parameter not passed, assumes default subclient.

.PARAMETER Entity
    Name of the Entity to be removed. Multiple entities can be added using a comma separated list. Virtual machine Name, datastore name etc.

.PARAMETER EntityType
    EntityType can be VMName (default), Host or Cluster etc.

.PARAMETER Force
    Switch to Force override of default 'WhatIf' confirmation behavior.

.EXAMPLE
    Remove-CVVirtualMachine -Entity LSRegVm1 -ClientName vsa-vc65.testlab.commvault.com

.EXAMPLE
    Remove-CVVirtualMachine -Entity LSRegVm1 -ClientName vsa-vc65.testlab.commvault.com -SubclientName LSRegVMG1    

.OUTPUTS
    Outputs [PSCustomObject] containing job submission result.
    If successful, specified content is removed from the subclient.

.NOTES
    Author: Gary Stoops
    Company: Commvault
#>
    [Alias('Remove-CVVM')]
    [CmdletBinding(DefaultParameterSetName = 'ByName', SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    [OutputType([PSCustomObject])]
    param(
        [Parameter(Mandatory = $True, ParameterSetName = 'ByName')]
        [ValidateNotNullorEmpty()]
        [String] $ClientName,

        [Parameter(Mandatory = $True, ParameterSetName = 'ByObject', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
        [ValidateNotNullorEmpty()]
        [System.Object] $ClientObject,

        [Parameter(Mandatory = $False)]
        [ValidateNotNullorEmpty()]
        [String] $SubclientName,

        [Parameter(Mandatory = $True)]
        [ValidateNotNullorEmpty()]
        [String] $Entity,

        [Parameter(Mandatory = $False)]
        [CVVSAContentEntityType] $EntityType = 'VMName',

        [Switch] $Force
    )

    begin { Write-Debug -Message "$($MyInvocation.MyCommand): begin"
    }

    process { Write-Debug -Message "$($MyInvocation.MyCommand): process"

        try {
            if ($PSCmdlet.ParameterSetName -eq 'ByName') {
                if (-not [String]::IsNullOrEmpty($SubclientName)) {
                    if ($Force) {
                        Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -ClientName $ClientName -SubclientName $SubclientName -OperationType 'DELETE' -Force
                    }
                    else {
                        Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -ClientName $ClientName -SubclientName $SubclientName -OperationType 'DELETE'
                    }
                }
                else {
                    if ($Force) {
                        Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -ClientName $ClientName -OperationType 'DELETE' -Force
                    }
                    else {
                        Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -ClientName $ClientName -OperationType 'DELETE'
                    }
                }
            }
            else {
                if (-not [String]::IsNullOrEmpty($SubclientName)) {
                    if ($Force) {
                        $ClientObject | Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -SubclientName $SubclientName -OperationType 'DELETE' -Force
                    }
                    else {
                        $ClientObject | Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -SubclientName $SubclientName -OperationType 'DELETE'
                    }
                }
                else {
                    if ($Force) {
                        $ClientObject | Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -OperationType 'DELETE' -Force
                    }
                    else {
                        $ClientObject | Add-CVVirtualMachine -Entity $Entity -EntityType $EntityType -OperationType 'DELETE'
                    }
                }
            }
        }
        catch {
            throw $_
        }
    }

    end { Write-Debug -Message "$($MyInvocation.MyCommand): end"
    }
}


# Function to prepare VM content. this returns an object that can be used for Add or Remove content REST API
function PrepareContentBodyJson ([HashTable] $EntityObj) {

    try {
        [System.Collections.ArrayList] $childrenNode_arr = @()

        if ($EntityObj.Entity) {
            $entities = $EntityObj.Entity -split ","
            if ($entities) {
                foreach ($entity in $entities) {
                    $vmProps = Get-CVVirtualMachine -Name $entity -ClientId $EntityObj.clientId
                    if ($null -ne $vmProps -and $null -ne $vmProps.strGUID) {
                        $uuid = $vmProps.strGUID
                    }
                    else {
                        Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine GUID not found for entity [$entity]"
                        continue
                    }

                    $vmObj = [ordered]@{ }
                    $vmObj.Add('allOrAnyChildren' , $True)
                    $vmObj.Add('displayName'      , $entity)
                    $vmObj.Add('equalsOrNotEquals', $True)
                    $vmObj.Add('name'             , $uuid)
                    $vmObj.Add('type'             , $EntityObj.EntityType.value__)
                    $vmObj.Add('path'             , '')
                    $null = $childrenNode_arr.Add($vmObj)
                }
            }
        }

        if ($childrenNode_arr.Count -eq 0) {
            return $null
        }

        $subClientProp = @{ }
        $children = @{ }
        $children.Add('children', $childrenNode_arr)
        $subClientPropertiesObj = @{ }
        $subClientPropertiesObj.Add('vmContentOperationType', $EntityObj.OperationType.ToString())
        $subClientPropertiesObj.Add('vmDiskFilterOperationType', 1)
        $subClientPropertiesObj.Add('vmFilterOperationType', 1)
        $subClientPropertiesObj.Add('vmContent' , $children)

        $subClientProp.Add('subClientProperties', $subClientPropertiesObj)
        #$rootObj.Add('App_UpdateSubClientPropertiesRequest', $subClientProp)
        $body = $subClientProp | ConvertTo-Json -Depth 10
        return @{ 'body' = $body }
    }
    catch {
        throw $_
    }
}


<# PrepareMountTaskBodyJson
VMLiveMountReq 
{
    boolean useSourceNetwork = false
    string networkName
    int jobId //this is to perform livemount from particular jobId
    string policyName
    string liveMountVMName
    int expirationInHours //this will work only for in-place livemount
} 
#>
function PrepareMountTaskBodyJson ([HashTable] $JobObj) {

    try {
        $createTaskReq = [ordered]@{}
        $vmLiveMountReq = [ordered]@{ }
        $vmLiveMountReq.Add('useSourceNetwork', $False)
        $vmLiveMountReq.Add('networkName', $JobObj.networkName)
        $vmLiveMountReq.Add('policyName', $JobObj.policyName)
        $vmLiveMountReq.Add('jobId', $JobObj.jobId)
        $vmLiveMountReq.Add('liveMountVMName', $JobObj.liveMountVMName)
        $vmLiveMountReq.Add('expirationInHours', $JobObj.expirationInHours)
        $createTaskReq.Add('VMLiveMountReq', $vmLiveMountReq)
        
        $body = $createTaskReq | ConvertTo-Json -Depth 10
        return @{ 'body' = $body }
    }
    catch {
        throw $_
    }
}


<# PrepareBackupTaskBodyJson
{
    "processinginstructioninfo": {
        "locale": {
            "_type_": 66,
            "localeId": 0
        },
        "formatFlags": {
            "skipIdToNameConversion": true
        },
        "user": {
            "_type_": 13,
            "userName": "",
            "userId": 1
        }
    },
    "taskInfo": {
        "associations": [
            {
                "srmReportSet": 0,
                "subclientId": 8,
                "srmReportType": 0,
                "commCellId": 2,
                "_type_": 3
            }
        ],
        "task": {
            "taskType": 1,
            "ownerName": "admin",
            "initiatedFrom": 1,
            "policyType": 0,
            "taskFlags": {
                "disabled": false
            }
        },
        "subTasks": [
            {
                "subTask": {
                    "subTaskName": "web sub task",
                    "subTaskType": 2,
                    "operationType": 2
                },
                "options": {
                    "backupOpts": {
                        "collectMetaInfo": false,
                        "backupLevel": 2,
                        "runIncrementalBackup": true,
                        "isSpHasInLineCopy": false,
                        "vsaBackupOptions": {
                            "backupFailedVMsOnly": false,
                            "selectiveVMInfo": [
                                {
                                    "vmGuid": "501b94e8-284d-cfac-c9d5-12cada55f66d"
                                }
                            ]
                        }
                    },
                    "adminOpts": {
                        "updateOption": {
                            "invokeLevel": 0
                        }
                    }
                }
            }
        ]
    }
}
#>
function PrepareBackupTaskBodyJson ([Hashtable] $jobObj, [String] $VMGuid) {

    try {
        #Building json
        
        $createTaskReq = [ordered] @{ }
        #processinginstructioninfo
        $processingInstructionInfo = [ordered]@{ }
        $locale = @{ }
        $locale.Add('_type_', 66)
        $locale.Add('localeId', 0)
        $formatFlags = @{ }
        $formatFlags.Add('skipIdToNameConversion', $True)
        $user = @{ }
        $user.Add('_type_', 13)
        $user.Add('userName', '')
        $user.Add('userId', 1)
        $processingInstructionInfo.Add('locale', $locale)
        $processingInstructionInfo.Add('formatFlags', $formatFlags)
        $processingInstructionInfo.Add('user', $user)

        #taskInfo
        $taskInfo = [ordered]@{ }
        $task = [ordered]@{ }
        $owner = $global:CVConnectionPool.user
        $task.Add('policyType', 0)
        $task.Add('taskType', 1)
        $task.Add('initiatedFrom', 1)
        $task.Add('ownerName', $owner)
        $taskFlags = @{ }
        $taskFlags.Add('disabled', $False)
        $task.Add('taskFlags', $taskFlags)

        #associations
        [System.Collections.ArrayList] $associations_arr = @()
        $temp_array = [ordered]@{ }
        $temp_array.Add('srmReportSet', 0)
        $temp_array.Add('clientId', $jobObj.clientId)
        $temp_array.Add('subclientId', $jobObj.subclientId)
        $temp_array.Add('srmReportType', 0)
        $temp_array.Add('commCellId', $jobObj.commCellId)
        $temp_array.Add('_type_', 3)
        $null = $associations_arr.Add($temp_array)

        #subtasks
        [System.Collections.ArrayList] $subTasks_arr = @()
        $subTasks_map = [ordered]@{ }
        $subTask = [ordered]@{ }
        $subTask.Add('subTaskName', 'web sub task')
        $subTask.Add('subTaskType', 2)
        $subTask.Add('operationType', $jobObj.backupLevel)
        $subTasks_map.Add('subTask', $subTask)

        #options
        $options = [ordered]@{ }
        $backupOpts = [ordered]@{ }
        $backupOpts.Add('backupLevel', $jobObj.backupLevel)
        $backupOpts.Add('runIncrementalBackup', $jobObj.runIncrementalBackup)
        $backupOpts.Add('isSpHasInLineCopy', $False)
        $backupOpts.Add('collectMetaInfo', $jobObj.collectMetaInfo)
        $vsaBackupOptions = @{ }
        $vsaBackupOptions.Add('backupFailedVMsOnly', $jobObj.backupFailedVMs)
        [System.Collections.ArrayList] $selectiveVMInfo_arr = @()
        $temp_array = @{ }
        $temp_array.Add('vmGuid', $VMGuid)
        $null = $selectiveVMInfo_arr.Add($temp_array)
        $vsaBackupOptions.Add('selectiveVMInfo', $selectiveVMInfo_arr)
        $backupOpts.Add('vsaBackupOptions', $vsaBackupOptions)
        $options.Add('backupOpts', $backupOpts)

        #adminOpts
        $adminOpts = @{ }
        $updateOption = @{ }
        $updateOption.Add('invokeLevel', 0)
        $adminOpts.Add('updateOption', $updateOption)
        $options.Add('adminOpts', $adminOpts)
        $subTasks_map.Add('options', $options)

        #SubTasks Array
        $null = $subTasks_arr.Add($subTasks_map)

        #Add sub sections to taskInfo
        $taskInfo.Add('associations', $associations_arr)
        $taskInfo.Add('task', $task)
        $taskInfo.Add('subTasks', $subTasks_arr)
        
        #Add subItems to the root
        $createTaskReq.Add('processinginstructioninfo', $processingInstructionInfo)
        $createTaskReq.Add('taskInfo', $taskInfo)

        #End of Json prep
        $body = $createTaskReq | ConvertTo-Json -Depth 10
        return @{ 'body' = $body }
    }
    catch {
        throw $_
    }
}


<# PrepareInPlaceTaskBodyJson
{
    "taskInfo": {
        "associations": [
            {
                "subclientId": 237,
                "applicationId": 106,
                "clientName": "TestVapp__34de6bd6-46db-4f2f-b228-5f37f0106258_",
                "clientId": 715
            }
        ],
        "task": {},
        "subTasks": [
            {
                "subTask": {
                    "subTaskType": 3,
                    "operationType": 1001
                },
                "options": {
                    "restoreOptions": {
                        "virtualServerRstOption": {
                            "isDiskBrowse": true,
                            "diskLevelVMRestoreOption": {
                                "passUnconditionalOverride": false,
                                "useVcloudCredentials": true,
                                "endUserVMRestore": true,
                                "vmClientId": 0,
                                "vmName": "TestVapp_AdminConsole_K1",
                                "powerOnVmAfterRestore": true,
                                "advancedRestoreOptions": [
                                    {
                                        "newName": "TestVapp_AdminConsole_K1",
                                        "name": "TestVapp__34de6bd6-46db-4f2f-b228-5f37f0106258_",
                                        "guid": "502d33a1-53ad-487b-6780-0248334cd2fd"
                                    }
                                ]
                            }
                        },
                        "volumeRstOption": {
                            "volumeLevelRestoreType": 1
                        },
                        "browseOption": {
                            "commCellId": 2,
                            "backupset": {
                                "clientId": 715
                            },
                            "timeRange": {}
                        },
                        "destination": {
                            "inPlace": false,
                            "destClient": {
                                "clientId": 9
                            }
                        },
                        "fileOption": {
                            "sourceItem": [
                                "\\502d33a1-53ad-487b-6780-0248334cd2fd"
                            ]
                        }
                    }
                }
            }
        ]
    }
}
#>
function PrepareInPlaceTaskBodyJson ([HashTable] $RestoreObject) {

    try {
        if ($null -ne $RestoreObject -and $null -ne $RestoreObject.vmProps) {
            $sessionObj = Get-CVSessionDetail 'InplaceRecover-VMDetails'
            $sessionObj.requestProps.endpoint = $sessionObj.requestProps.endpoint -creplace ('{vmGUID}', $RestoreObject.vmProps.strGUID)

            $headerObj = Get-CVRESTHeader $sessionObj
            $body = ''
            $payload = @{ }
            $payload.Add('headerObject', $headerObj)
            $payload.Add('body', $body)
            $validate = 'vmStatusInfoList'
            
            $response = Submit-CVRESTRequest $payload $validate

            if ($response.IsValid) {
                #root element
                $rootElement = [ordered]@{ }
                $taskInfo = [ordered]@{ }
                #Associations
                [System.Collections.ArrayList] $associations_arr = @()
                $associationsdict = @{ }
                $associationsdict.Add('subclientId', $response.Content.vmStatusInfoList.subclientId)
                $associationsdict.Add('applicationId', 106)
                $associationsdict.Add('clientName', $response.Content.vmStatusInfoList.pseudoClient.clientName)
                $associationsdict.Add('clientId', $response.Content.vmStatusInfoList.pseudoClient.clientId)
                $null = $associations_arr.Add($associationsdict)
                
                $task = [ordered]@{ }

                #subtasks
                $subTasks = [ordered]@{ }
                [System.Collections.ArrayList] $subTasks_arr = @()
                $subTask = [ordered]@{ }
                $subTask.Add('subTaskType', 3)
                $subTask.Add('operationType', 101)
                $subTasks.Add('subTask', $subTask)

                #options
                $options = [ordered]@{ }
                $restoreOptions = [ordered]@{ }
                $virtualServerRstOption = @{ }
                $virtualServerRstOption.Add('isDiskBrowse', $True)
                $diskLevelVMRestoreOption = @{ }
                $diskLevelVMRestoreOption.Add('passUnconditionalOverride', $Overwrite) #unconditional overwrite Flag
                $diskLevelVMRestoreOption.Add('useVcloudCredentials', $False)
                $diskLevelVMRestoreOption.Add('endUserVMRestore', $True)
                $diskLevelVMRestoreOption.Add('vmClientId', 0)
                $diskLevelVMRestoreOption.Add('vmName', $response.Content.vmStatusInfoList.name)
                $diskLevelVMRestoreOption.Add('powerOnVmAfterRestore', $True)

                [System.Collections.ArrayList] $advancedRestoreOptions_arr = @()
                $advancedRestoreOptions = @{ }
                $advancedRestoreOptions.Add('newName', $response.Content.vmStatusInfoList.name)
                $advancedRestoreOptions.Add('name', $response.Content.vmStatusInfoList.name)
                $advancedRestoreOptions.Add('guid', $response.Content.vmStatusInfoList.strGUID)
                $null = $advancedRestoreOptions_arr.Add($advancedRestoreOptions)
                $diskLevelVMRestoreOption.Add('advancedRestoreOptions', $advancedRestoreOptions_arr)
                
                $virtualServerRstOption.Add('diskLevelVMRestoreOption', $diskLevelVMRestoreOption)
                
                $restoreOptions.Add('virtualServerRstOption', $virtualServerRstOption)

                #VolumeRstOption
                $volumeRstOption = @{ }
                $volumeRstOption.Add('volumeLevelRestoreType', 1)
                
                $restoreOptions.Add('volumeRstOption', $volumeRstOption)

                #browseOption
                $browseOption = @{ }
                #Commcell ID
                $globalObj = Get-CVCommCellGlobals
                $browseOption.Add('commCellId', $globalObj.commCellId)
                $backupset = @{ }
                $backupset.Add('clientId', $response.Content.vmStatusInfoList.pseudoClient.clientId)
                $browseOption.Add('backupset', $backupset)
                $timeRange = @{ }
                $browseOption.Add('timeRange', $timeRange)

                $restoreOptions.Add('browseOption', $browseOption)

                #destination
                $destination = @{ }
                #Inplace flag
                $destination.Add('inPlace', $RestoreObject.inPlaceRestore)
                $destClient = @{ }
                $destClient.Add('clientId', $response.Content.vmStatusInfoList.proxyClient.clientId)
                $destination.Add('destClient', $destClient)

                $restoreOptions.Add('destination', $destination)

                #fileOption
                $fileOption = @{ }
                [System.Collections.ArrayList] $sourceItem_arr = @()
                $path = '\\' + $response.Content.vmStatusInfoList.strGUID
                $null = $sourceItem_arr.Add($path)
                $fileOption.Add('fileOption', $sourceItem_arr)

                $restoreOptions.Add('fileOption', $fileOption)
                
                $options.Add('restoreOptions', $restoreOptions)
            
                $subTasks.Add('options', $options)

                $null = $subTasks_arr.Add($subTasks)
                
                $taskInfo.Add('associations', $associations_arr)
                $taskInfo.Add('task', $task)
                $taskInfo.Add('subTasks', $subTasks_arr)

                $rootElement.Add('taskInfo', $taskInfo)
        
                #End of Json prep
                $body = $rootElement | ConvertTo-Json -Depth 10
                return @{ 'body' = $body }
            }
            else {
                Write-Information -InformationAction Continue -MessageData "INFO: $($MyInvocation.MyCommand): virtual machine details not found for GUID [$($vmObj.strGUID)]"      
            }
        }
        else {
            return $null
        }
    }
    catch {
        throw $_
    }
}


# Method validates the user input for out-of-place Restores and returns the map with values needed for out of place
function ParseOutOfPlaceRestoreOptions([HashTable] $Options, [CVVSAHyperVisorType] $HvType) {
    
    try {
        $restoreOptions = @{ }
    
        if ($HvType -eq 'vmware') { #VMware specific code
            if ($null -ne $Options) {
                $restoreOptions.Add('destinationInfo', $True)
                if ($Options.esxHost) { $restoreOptions.Add('esxHost', $Options.esxHost) }
                if ($Options.esxHost) { $restoreOptions.Add('dataStore', $Options.dataStore) }
                if ($Options.esxHost) { $restoreOptions.Add('resourcePool', $Options.resourcePool) }
                if ($Options.esxHost) { $restoreOptions.Add('vmfolder', $Options.vmfolder) }
                if ($Options.esxHost) { $restoreOptions.Add('newName', $Options.newName) }
            }
            if ($Options.vmFileLevelRestoreOptions) { $restoreOptions.Add('vmFileLevelRestoreOptions', $True) }
        }
    
        return $restoreOptions
    }
    catch {
        throw $_
    }
}


<# PrepareOutofPlaceTaskBodyJson
{
    "powerOnVmAfterRestore": "string",
    "passUnconditionalOverride": "string",
    "inPlaceRestore": "string",
    "JobId": "string",
    "copyPrecedence": "string",
    "destinationClient": {
        "clientName": "string"
    },
    "vmFileLevelRestoreOptions": {
        "sourcePath": [
            "string"
        ],
        "destPath": "string",
        "guestCredentials": {
            "userName": "string",
            "password": "string"
        }
    },
    "destinationInfo": [
        {
            "vmware": {
                "esxHost": "string",
                "dataStore": "string",
                "resourcePool": "string",
                "vmfolder": "string",
                "newName": "string"
            },
            "hyperv": {
                "Server": "string",
                "destinationPath": "string",
                "registerwithFailover": "string",
                "newName": "string"
            }
        }
    ]
}
#>
function PrepareOutofPlaceTaskBodyJson ([HashTable] $RestoreObject) {

    try {
        if ($RestoreObject) {
            $inPlaceFlag = $False
            $VMProp = $RestoreObject.VMProp
            $Overwrite = [System.Convert]::ToBoolean($RestoreObject.Overwrite)
            $powerState = [System.Convert]::ToBoolean($RestoreObject.powerOn)
            $taskInfo = [ordered]@{ }
            if (-not $RestoreObject.JobId -eq $null) {
                $JobId = [System.Convert]::ToInt16($RestoreObject.JobId)
            }
            
            $taskInfo.Add('powerOnVmAfterRestore', $powerState)
            $taskInfo.Add('passUnconditionalOverride', $Overwrite)
            $taskInfo.Add('inPlaceRestore', $inPlaceFlag)
            if ($JobId)
            { $taskInfo.Add('JobId', $JobId) }
            if (-not $RestoreObject.CopyPrecedence -eq 0) {
                $copyNumber = [System.Convert]::ToInt16($RestoreObject.CopyPrecedence)
                $taskInfo.Add('copyPrecedence', $copyNumber)
            }

            $destinationClient = @{ }
            $destinationClient.Add('clientName', $RestoreObject.ClientName)
            $taskInfo.Add('destinationClient', $destinationClient)
            if ($RestoreObject.ContainsKey('OutofPlaceProps')) {
                if ($RestoreObject.OutofPlaceProps.vmFileLevelRestoreOptions) {
                    ##Out of place restores for each virtual disk
                    $vmFileLevelRestoreOptions = @{ }
                    [System.Collections.ArrayList] $sourcePath_arr = @()
                    $null = $sourcePath_arr.Add($RestoreObject.OutofPlaceProps.sourcePath)
                    $vmFileLevelRestoreOptions.Add('sourcePath', $sourcePath_arr)
                    $vmFileLevelRestoreOptions.Add('destPath', $RestoreObject.OutofPlaceProps.destPath)
                    $guestCredentials = @{ }
                    $guestCredentials.Add('userName', $RestoreObject.OutofPlaceProps.guestUser)
                    $guestCredentials.Add('password', $RestoreObject.OutofPlaceProps.guestPwd)
                    $vmFileLevelRestoreOptions.Add('guestCredentials', $guestCredentials)
                    $taskInfo.Add('vmFileLevelRestoreOptions', $vmFileLevelRestoreOptions)
                }

                if ($RestoreObject.OutofPlaceProps.destinationInfo) {
                    ##Add any hypervisor specific values for the restore
                    $destinationInfo = @{ }
                    [System.Collections.ArrayList] $destnationInfo_arr = @()
                    if ($RestoreObject.hypervisorType -eq 101) {
                        $vmware = @{ }
                        $vmware.Add('esxHost', $RestoreObject.OutofPlaceProps.esxHost)
                        $vmware.Add('dataStore', $RestoreObject.OutofPlaceProps.dataStore)
                        $vmware.Add('resourcePool', $RestoreObject.OutofPlaceProps.resourcePool)
                        $vmware.Add('vmfolder', $RestoreObject.OutofPlaceProps.vmfolder)
                        $vmware.Add('newName', $RestoreObject.OutofPlaceProps.newName)
                        $destinationInfo.Add('vmware', $vmware)
                    }
                    
            
                    if ($RestoreObject.hypervisorType -eq 102) {
                        $hyperv = @{ }
                        $hyperv.Add('server', $RestoreObject.OutofPlaceProps.Server)
                        $hyperv.Add('destinationPath', $RestoreObject.OutofPlaceProps.destinationPath)
                        $hyperv.Add('resourcePool', $RestoreObject.OutofPlaceProps.resourcePool)
                        $hyperv.Add('registerwithFailover', $RestoreObject.OutofPlaceProps.registerwithFailover)
                        $hyperv.Add('newName', $RestoreObject.OutofPlaceProps.newName)
                        $destinationInfo.Add('hyperv', $hyperv)
                    }
                    $null = $destnationInfo_arr.Add($destinationInfo)
                    $taskInfo.Add('destinationInfo', $destnationInfo_arr)
                }

                #End of Json prep
                $body = $taskInfo | ConvertTo-Json -Depth 10
                return @{ 'body' = $body }
            }
            else {
                Write-Error("Error - VMproperty object found null " + $VMProp)
            
            }
            #End of Json prep
            $body = $taskInfo | ConvertTo-Json -Depth 10
            return @{ 'body' = $body }

        }#End of if ($RestoreObj)
    }#End of Try
    catch {
        throw $_
    }
}


function GetVirtualMachineEntityObject {

    try {
        $entityObj  = @{}
        $entityObj.Add('entity', '')           #Entity Name can be say: VM name in format like VM1, VM2, VM3
        $entityObj.Add('entityType', '')       #Virtualization entity type. ESX Host, Datastore, VM, Cluster...etc 
        $entityObj.Add('operationType', '')    #DELETE or ADD  or OVERWRITE
        $entityObj.Add('clientId', '')         #Virtualization clientId
        
        return $entityObj
    }
    catch {
        throw $_
    }
}


function GetVirtualMachineJobObject() {

    try {
        $jobObj = @{ }
        $jobObj.Add('clientId', '')                #Virtualization Client Id
        $jobObj.Add('subclientId', '')             #Subclient or Collection Id    
        $jobObj.Add('vmName', '')                  #VM name 
        $jobObj.Add('commCellId', 2)               #Commcell Id. Default it is set to 2
        $jobObj.Add('backupLevel', 2)              #BackupLevel: Full - 1, Incrmental - 2, Synthfull - 3
        $jobObj.Add('runIncrementalBackup', $True) #RunIncremental by default set to 1
        $jobObj.Add('backupFailedVMs', $False)     #Backup failedVMs only option.  If set to 1, job will backup only failed VMs
        $jobObj.Add('collectMetaInfo', $False)     #If set to 1, metadata will be collected
        $jobObj.Add('subclientObj', '')  
        $jobObj.Add('subTaskType', 2)  
        $jobObj.Add('operationType', 2)            #Backup or Restore
        $jobObj.Add('taskType', 1)                 #Backup or Restore

        return $jobObj
    }
    catch {
        throw $_
    }
}


# Internal use: takes $PSCmdlet.PagingParameters and returns a hashtable paging flag, page size, and page start index
function ValidatePagingParameters($PagingParameters, [UInt64] $TotalCount) {

    try {
        $pagingObj = @{ 'paging' = 0; 'pageSize' = $null; 'startPage' = $null; 'badParams' = $False }

        [UInt64] $PageSize = [Math]::Max($PagingParameters.First, 0)
        [UInt64] $StartPage = [Math]::Max($PagingParameters.Skip, 0)

        if ($PageSize -lt [Uint64]::MaxValue) { # MaxValue is system default
            if ($PageSize -gt 0 -and $PageSize -le $TotalCount) {
                if ($StartPage -lt ($TotalCount / $PageSize)) {
                    $pagingObj['paging'] = 1
                    $pagingObj['pageSize'] = $PageSize
                    $pagingObj['startPage'] = $StartPage
                }
                elseif ($StartPage -gt 0) {
                    $pagingObj['badParams'] = $True
                    Write-Warning -Message "$($MyInvocation.MyCommand): paging parameter -Skip [$StartPage] beyond end of record set"
                }
            }
            elseif ($PageSize -gt 0) {
                $pagingObj['badParams'] = $True
                Write-Warning -Message "$($MyInvocation.MyCommand): paging parameter -First [$PageSize] exceeds total record count"
            }
        }

        Write-Output $pagingObj
    }
    catch {
        throw $_
    }
}

function HasProperty($Object, $PropertyName)
{
    $PropertyName -in $Object.PSobject.Properties.Name
}